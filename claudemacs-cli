#!/usr/bin/env python3
"""
claudemacs-cli - Command-line interface for Claude AI to interact with Emacs

This CLI provides a safe, permission-gated way for Claude to interact with
Emacs buffers via emacsclient.
"""

import argparse
import json
import os
import subprocess
import sys


def get_socket_path():
    """Determine the Emacs server socket path."""
    # Priority order: CLAUDEMACS_SOCKET > EMACS_SERVER_FILE > default
    if socket := os.environ.get('CLAUDEMACS_SOCKET'):
        return socket
    if server_file := os.environ.get('EMACS_SERVER_FILE'):
        return server_file

    # Default location
    emacs_dir = os.path.expanduser('~/.emacs.d')
    return os.path.join(emacs_dir, 'server', 'server')


def call_emacs(elisp_expr, socket=None, timeout=30):
    """Call emacsclient with an elisp expression."""
    if socket is None:
        socket = get_socket_path()

    cmd = ['emacsclient', '--socket-name', socket, '--eval', elisp_expr]

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=timeout
        )

        if result.returncode != 0:
            print(f"Error: {result.stderr}", file=sys.stderr)
            sys.exit(1)

        return result.stdout.strip()

    except subprocess.TimeoutExpired:
        print("Error: Command timed out", file=sys.stderr)
        sys.exit(1)
    except FileNotFoundError:
        print("Error: emacsclient not found. Is Emacs installed?", file=sys.stderr)
        sys.exit(1)


def escape_elisp_string(s):
    """Escape a string for use in elisp."""
    # Escape backslashes first, then quotes
    return s.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n')


def cmd_insert(args):
    """Insert text into a buffer."""
    escaped_text = escape_elisp_string(args.text)
    elisp = f'(claudemacs-ai-insert-in-buffer "{args.buffer}" "{escaped_text}")'
    result = call_emacs(elisp, args.socket)
    print(result)


def cmd_get_content(args):
    """Get buffer content."""
    if args.tail:
        elisp = f'(claudemacs-ai-get-buffer-content "{args.buffer}" {args.tail})'
    else:
        elisp = f'(claudemacs-ai-get-buffer-content "{args.buffer}")'
    result = call_emacs(elisp, args.socket)
    # Result comes back as a quoted string, strip the quotes
    if result.startswith('"') and result.endswith('"'):
        result = result[1:-1]
        # Unescape elisp string escapes
        result = result.replace('\\n', '\n').replace('\\"', '"').replace('\\\\', '\\')
    print(result)


def cmd_get_region(args):
    """Get content from a region."""
    elisp = f'(claudemacs-ai-get-region "{args.buffer}" {args.start} {args.end})'
    result = call_emacs(elisp, args.socket)
    if result.startswith('"') and result.endswith('"'):
        result = result[1:-1]
        result = result.replace('\\n', '\n').replace('\\"', '"').replace('\\\\', '\\')
    print(result)


def cmd_replace_region(args):
    """Replace region content."""
    escaped_text = escape_elisp_string(args.text)
    elisp = f'(claudemacs-ai-replace-region "{args.buffer}" {args.start} {args.end} "{escaped_text}")'
    result = call_emacs(elisp, args.socket)
    print(result)


def cmd_list_buffers(args):
    """List all buffers."""
    elisp = '(claudemacs-ai-list-buffers)'
    result = call_emacs(elisp, args.socket)
    # Parse the elisp list output
    print(result)


def cmd_buffer_info(args):
    """Get buffer information."""
    elisp = f'(claudemacs-ai-buffer-info "{args.buffer}")'
    result = call_emacs(elisp, args.socket)
    print(result)


def cmd_goto_point(args):
    """Move point in buffer."""
    elisp = f'(claudemacs-ai-goto-point "{args.buffer}" {args.position})'
    result = call_emacs(elisp, args.socket)
    print(result)


def cmd_send_input(args):
    """Send input to a REPL buffer."""
    escaped_text = escape_elisp_string(args.text)
    elisp = f'(claudemacs-ai-send-input "{args.buffer}" "{escaped_text}")'
    result = call_emacs(elisp, args.socket)
    print(result)


def cmd_exec_in_terminal(args):
    """Execute command in eat terminal and wait for completion."""
    escaped_cmd = escape_elisp_string(args.command)
    timeout = args.timeout if args.timeout else 30
    elisp = f'(claudemacs-ai-exec-in-eat-terminal "{args.buffer}" "{escaped_cmd}" {timeout})'
    # Give emacsclient extra time beyond the command timeout
    result = call_emacs(elisp, args.socket, timeout=timeout + 10)
    # Result comes back as a quoted string, strip the quotes
    if result.startswith('"') and result.endswith('"'):
        result = result[1:-1]
        # Unescape elisp string escapes
        result = result.replace('\\n', '\n').replace('\\"', '"').replace('\\\\', '\\')
    print(result)


def cmd_eval(args):
    """Evaluate arbitrary elisp (use with caution)."""
    result = call_emacs(args.expression, args.socket)
    print(result)


def main():
    parser = argparse.ArgumentParser(
        description='Claude AI interface to Emacs',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    # Global options
    parser.add_argument(
        '--socket',
        help='Emacs server socket path (default: from env or ~/.emacs.d/server/server)'
    )

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # insert-in-buffer
    p = subparsers.add_parser('insert-in-buffer', help='Insert text into buffer')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('text', help='Text to insert')
    p.set_defaults(func=cmd_insert)

    # get-buffer-content
    p = subparsers.add_parser('get-buffer-content', help='Get entire buffer content')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('--tail', type=int, help='Get only the last N lines')
    p.set_defaults(func=cmd_get_content)

    # get-region
    p = subparsers.add_parser('get-region', help='Get content from region')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('start', type=int, help='Start position')
    p.add_argument('end', type=int, help='End position')
    p.set_defaults(func=cmd_get_region)

    # replace-region
    p = subparsers.add_parser('replace-region', help='Replace region content')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('start', type=int, help='Start position')
    p.add_argument('end', type=int, help='End position')
    p.add_argument('text', help='Replacement text')
    p.set_defaults(func=cmd_replace_region)

    # list-buffers
    p = subparsers.add_parser('list-buffers', help='List all buffers')
    p.set_defaults(func=cmd_list_buffers)

    # buffer-info
    p = subparsers.add_parser('buffer-info', help='Get buffer information')
    p.add_argument('buffer', help='Buffer name')
    p.set_defaults(func=cmd_buffer_info)

    # goto-point
    p = subparsers.add_parser('goto-point', help='Move point to position')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('position', type=int, help='Position')
    p.set_defaults(func=cmd_goto_point)

    # send-input
    p = subparsers.add_parser('send-input', help='Send input to REPL buffer')
    p.add_argument('buffer', help='Buffer name')
    p.add_argument('text', help='Text to send')
    p.set_defaults(func=cmd_send_input)

    # exec-in-terminal
    p = subparsers.add_parser('exec-in-terminal', help='Execute command in eat terminal and wait for completion')
    p.add_argument('buffer', help='Buffer name (eat terminal)')
    p.add_argument('command', help='Command to execute')
    p.add_argument('--timeout', type=int, help='Timeout in seconds (default: 30)')
    p.set_defaults(func=cmd_exec_in_terminal)

    # eval
    p = subparsers.add_parser('eval', help='Evaluate elisp expression')
    p.add_argument('expression', help='Elisp expression')
    p.set_defaults(func=cmd_eval)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == '__main__':
    main()
